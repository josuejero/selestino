

Please analyze this project structure, description, and errors carefully in order to help me with the issue.

### README.md ###
# Selestino

Selestino is a recipe website where users can input available ingredients and get relevant recipes for Peruvian dishes. This project leverages a variety of technologies including Golang, PostgreSQL, Docker, Kubernetes, and Jenkins for CI/CD.

## Table of Contents

- [Project Overview](#project-overview)
- [Features](#features)
- [Technologies Used](#technologies-used)
- [Setup and Installation](#setup-and-installation)
  - [Prerequisites](#prerequisites)
  - [Installation](#installation)
- [Usage](#usage)
  - [Running the Application](#running-the-application)
  - [API Endpoints](#api-endpoints)
- [Testing](#testing)
- [CI/CD Pipeline](#cicd-pipeline)
- [Contributing](#contributing)
- [License](#license)

## Project Overview

Selestino is designed to help users find Peruvian recipes based on the ingredients they have on hand. Users can register, log in, and search for recipes. The application supports JWT-based authentication and includes CI/CD pipelines for continuous integration and deployment.

## Features

- User registration and authentication
- Search recipes by ingredients and other criteria
- RESTful API for interacting with the application
- CI/CD pipeline with Jenkins
- Dockerized application for easy deployment
- Kubernetes for container orchestration

## Technologies Used

- Golang
- PostgreSQL
- Docker
- Kubernetes
- Jenkins
- JWT (JSON Web Tokens)
- Gorilla Mux
- Testify (testing framework)
- SQLMock (mocking SQL for tests)

## Setup and Installation

### Prerequisites

Ensure you have the following installed:

- Golang 1.20 or later
- Docker
- Docker Compose
- Kubernetes (Minikube or any other local Kubernetes setup)
- Jenkins (with necessary plugins)
- Git

### Installation

1. Clone the repository:

    ```bash
    git clone https://github.com/josuejero/selestino.git
    cd selestino
    ```

2. Set up the environment variables:

    Create a `.env` file in the root directory with the following content:

    ```env
    DB_HOST=postgres
    DB_PORT=5432
    DB_USER=selestino_user
    DB_PASSWORD=your_password
    DB_NAME=selestino
    JWT_SECRET_KEY=my_secret_key
    ```

3. Build and run the Docker containers:

    ```bash
    docker-compose up --build
    ```

4. Set up the Kubernetes environment:

    ```bash
    minikube start
    eval $(minikube -p minikube docker-env)
    docker build -t selestino:latest .
    kubectl apply -f k8s/postgres-deployment.yaml
    kubectl apply -f k8s/selestino-deployment.yaml
    ```

5. Access the application:

    ```bash
    minikube service selestino --url
    ```

## Usage

### Running the Application

After following the installation steps, you can access the application using the Minikube service URL. Use a tool like Postman or cURL to interact with the API endpoints.

### API Endpoints

- **Register User**
    ```http
    POST /register
    ```

    **Request Body:**
    ```json
    {
        "username": "exampleuser",
        "password": "password123"
    }
    ```

- **Login User**
    ```http
    POST /login
    ```

    **Request Body:**
    ```json
    {
        "username": "exampleuser",
        "password": "password123"
    }
    ```

- **Get All Recipes**
    ```http
    GET /recipes
    ```

- **Add Recipe**
    ```http
    POST /recipes
    ```

    **Request Body:**
    ```json
    {
        "name": "Lomo Saltado",
        "ingredients": "Beef, Onion, Tomato, Soy Sauce",
        "instructions": "Stir-fry ingredients and serve with rice"
    }
    ```

- **Search Recipes by Ingredients**
    ```http
    GET /recipes/search?ingredients=Beef,Tomato
    ```

## Testing

Run the tests to ensure all functionality is working correctly:

```bash
go test ./internal/repository
```

## CI/CD Pipeline

The CI/CD pipeline is set up using Jenkins. It automates the build, push, and deployment processes. The `Jenkinsfile` in the root directory defines the pipeline stages.

To configure the Jenkins pipeline:

1. Install Jenkins and necessary plugins.
2. Create credentials in Jenkins for Docker Hub and Kubernetes.
3. Create a new pipeline job and configure it to use the repository's `Jenkinsfile`.

## Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository.
2. Create a new branch (`git checkout -b feature-branch`).
3. Make your changes and commit them (`git commit -m 'Add new feature'`).
4. Push to the branch (`git push origin feature-branch`).
5. Create a pull request.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.


.
├── Jenkinsfile
├── LICENSE
├── README.md
├── alertmanager-instance.yaml
├── all_code.txt
├── api
│   ├── handlers.go
│   ├── handlers_test.go
│   ├── middleware.go
│   ├── middleware_test.go
│   ├── rate_limiter.go
│   ├── rate_limiter_test.go
│   ├── router.go
│   └── token_helper.go
├── cmd
│   └── main.go
├── docker-compose.yml
├── dockerfile
├── go.mod
├── go.sum
├── initdb
│   └── init.sql
├── internal
│   ├── models
│   │   ├── recipe.go
│   │   └── user.go
│   └── repository
│       ├── mock_db.go
│       ├── mock_recipe_repository.go
│       ├── recipe_repository.go
│       ├── recipe_repository_test.go
│       ├── user_repository.go
│       └── user_repository_test.go
├── jenkins-cli.jar
├── jenkins-deployment.yaml
├── jenkins_backup.tar
├── k8s
│   ├── elasticsearch-deployment.yaml
│   ├── kibana-deployment.yaml
│   ├── postgres-deployment.yaml
│   ├── redis-deployment.yaml
│   └── selestino-deployment.yaml
├── kubeconfig
├── kubectl
├── pkg
│   └── config
│       ├── cache.go
│       ├── config.go
│       └── search.go
├── problem.py
├── prometheus-crds.yaml
├── prometheus-instance.yaml
├── prometheus-operator-bundle.yaml
├── prometheus-operator-components.yaml
├── prometheus_setup_output.log
└── values.yaml

10 directories, 47 files

### ./cmd/main.go ###
package main

import (
	"net/http"

	"github.com/josuejero/selestino/api"
	"github.com/josuejero/selestino/pkg/config"
	"github.com/sirupsen/logrus"
)

func main() {
	db := config.Connect()
	defer db.Close()

	config.InitRedis()
	config.InitElasticsearch()

	logrus.SetFormatter(&logrus.JSONFormatter{})

	router := api.InitializeRouter(db)

	logrus.Info("Starting server on :8080")
	if err := http.ListenAndServe(":8080", router); err != nil {
		logrus.Fatalf("could not start server: %v", err)
	}
}
### ./go.mod ###
module github.com/josuejero/selestino

go 1.19

require (
	github.com/DATA-DOG/go-sqlmock v1.5.2 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/dgrijalva/jwt-go v3.2.0+incompatible // indirect
	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
	github.com/go-redis/redis/v8 v8.11.5 // indirect
	github.com/gorilla/mux v1.8.1 // indirect
	github.com/hashicorp/golang-lru v1.0.2 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/lib/pq v1.10.9 // indirect
	github.com/mailru/easyjson v0.7.7 // indirect
	github.com/olivere/elastic/v7 v7.0.32 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/stretchr/testify v1.9.0 // indirect
	golang.org/x/crypto v0.24.0 // indirect
	golang.org/x/sys v0.21.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
### ./LICENSE ###
MIT License

Copyright (c) 2024 Josue Jeronimo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
### ./dockerfile ###
# Use the official Golang image as the base image
FROM golang:1.20-alpine

# Set the working directory inside the container
WORKDIR /app

# Copy the go.mod and go.sum files
COPY go.mod go.sum ./

# Download the Go module dependencies
RUN go mod download

# Copy the rest of the application code
COPY . .

# Build the Go application
RUN go build -o selestino ./cmd

# Expose the application port
EXPOSE 8080

# Set the entry point to run the application
CMD ["./selestino"]
### ./k8s/selestino-deployment.yaml ###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: selestino
spec:
  replicas: 1
  selector:
    matchLabels:
      app: selestino
  template:
    metadata:
      labels:
        app: selestino
    spec:
      containers:
        - name: selestino
          image: josuejero/selestino:latest
          env:
            - name: DB_HOST
              value: postgres
            - name: DB_PORT
              value: "5432"
            - name: DB_USER
              value: selestino_user
            - name: DB_PASSWORD
              value: your_password
            - name: DB_NAME
              value: selestino
            - name: JWT_SECRET_KEY
              value: my_secret_key
            - name: REDIS_ADDR
              value: redis:6379
            - name: ELASTICSEARCH_URL
              value: http://elasticsearch:9200
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: "512Mi"
              cpu: "0.25"
            limits:
              memory: "1Gi"
              cpu: "0.5"
---
apiVersion: v1
kind: Service
metadata:
  name: selestino
spec:
  type: NodePort
  selector:
    app: selestino
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
      nodePort: 30000  # You can choose any available node port between 30000-32767

### ./k8s/elasticsearch-deployment.yaml ###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: elasticsearch
spec:
  replicas: 1
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
        - name: elasticsearch
          image: docker.elastic.co/elasticsearch/elasticsearch:7.10.1
          ports:
            - containerPort: 9200
          env:
            - name: discovery.type
              value: single-node
          resources:
            requests:
              memory: "2Gi"
              cpu: "0.5"
            limits:
              memory: "4Gi"
              cpu: "1"
---
apiVersion: v1
kind: Service
metadata:
  name: elasticsearch
spec:
  ports:
    - port: 9200
  selector:
    app: elasticsearch
### ./k8s/postgres-deployment.yaml ###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:13
          env:
            - name: POSTGRES_DB
              value: selestino
            - name: POSTGRES_USER
              value: selestino_user
            - name: POSTGRES_PASSWORD
              value: your_password
          ports:
            - containerPort: 5432
          resources:
            requests:
              memory: "512Mi"
              cpu: "0.25"
            limits:
              memory: "1Gi"
              cpu: "0.5"
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: postgres-storage
      volumes:
        - name: postgres-storage
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: postgres
spec:
  selector:
    app: postgres
  ports:
    - protocol: TCP
      port: 5432
      targetPort: 5432
### ./k8s/kibana-deployment.yaml ###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      containers:
        - name: kibana
          image: docker.elastic.co/kibana/kibana:7.10.0
          ports:
            - containerPort: 5601
          resources:
            requests:
              memory: "1.5Gi"
              cpu: "0.5"
            limits:
              memory: "3Gi"
              cpu: "1"


---
apiVersion: v1
kind: Service
metadata:
  name: kibana
  namespace: monitoring
spec:
  ports:
  - port: 5601
  selector:
    app: kibana
### ./k8s/redis-deployment.yaml ###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
        - name: redis
          image: redis:latest
          ports:
            - containerPort: 6379
          resources:
            requests:
              memory: "256Mi"
              cpu: "0.25"
            limits:
              memory: "512Mi"
              cpu: "0.5"
---
apiVersion: v1
kind: Service
metadata:
  name: redis
spec:
  selector:
    app: redis
  ports:
    - protocol: TCP
      port: 6379
      targetPort: 6379
### ./initdb/init.sql ###
CREATE TABLE IF NOT EXISTS recipes (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    ingredients TEXT NOT NULL,
    instructions TEXT NOT NULL
);
### ./internal/repository/recipe_repository.go ###
package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"strconv"

	"github.com/josuejero/selestino/internal/models"
	"github.com/josuejero/selestino/pkg/config"
	"github.com/olivere/elastic/v7"
)

type RecipeRepositoryInterface interface {
	GetAllRecipes() ([]models.Recipe, error)
	AddRecipe(recipe models.Recipe) error
	SearchRecipesByCriteria(criteria map[string]string) ([]models.Recipe, error)
}

type RecipeRepository struct {
	DB *sql.DB
}

var _ RecipeRepositoryInterface = &RecipeRepository{}

func (r *RecipeRepository) GetAllRecipes() ([]models.Recipe, error) {
	ctx := context.Background()
	cacheKey := "all_recipes"

	// Try to get the result from Redis cache
	cachedResult, err := config.GetRedis(ctx, cacheKey)
	if err == nil && cachedResult != "" {
		var recipes []models.Recipe
		if err := json.Unmarshal([]byte(cachedResult), &recipes); err == nil {
			return recipes, nil
		}
	}

	// If cache miss, query the database
	rows, err := r.DB.Query("SELECT id, name, ingredients, instructions FROM recipes")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var recipes []models.Recipe
	for rows.Next() {
		var recipe models.Recipe
		if err := rows.Scan(&recipe.ID, &recipe.Name, &recipe.Ingredients, &recipe.Instructions); err != nil {
			return nil, err
		}
		recipes = append(recipes, recipe)
	}

	// Cache the result in Redis
	serializedRecipes, err := json.Marshal(recipes)
	if err == nil {
		config.SetRedis(ctx, cacheKey, serializedRecipes)
	}

	return recipes, nil
}

func (r *RecipeRepository) AddRecipe(recipe models.Recipe) error {
	result, err := r.DB.Exec("INSERT INTO recipes (name, ingredients, instructions) VALUES ($1, $2, $3)",
		recipe.Name, recipe.Ingredients, recipe.Instructions)

	if err != nil {
		return err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return err
	}

	// Index document in Elasticsearch
	err = config.IndexDocument("recipes", strconv.FormatInt(id, 10), recipe)
	if err != nil {
		return err
	}

	// Invalidate cache
	ctx := context.Background()
	config.DelRedis(ctx, "all_recipes")

	return nil
}

func (r *RecipeRepository) SearchRecipesByCriteria(criteria map[string]string) ([]models.Recipe, error) {
	query := elastic.NewBoolQuery()
	for key, value := range criteria {
		query = query.Must(elastic.NewMatchQuery(key, value))
	}

	searchResult, err := config.ESClient.Search().
		Index("recipes").
		Query(query).
		Do(context.Background())
	if err != nil {
		return nil, err
	}

	var recipes []models.Recipe
	for _, hit := range searchResult.Hits.Hits {
		var recipe models.Recipe
		err := json.Unmarshal(hit.Source, &recipe)
		if err != nil {
			return nil, err
		}
		recipes = append(recipes, recipe)
	}

	return recipes, nil
}
### ./internal/repository/mock_recipe_repository.go ###
package repository

import (
	"github.com/josuejero/selestino/internal/models"
	"github.com/stretchr/testify/mock"
)

type MockRecipeRepository struct {
	mock.Mock
}

func (m *MockRecipeRepository) GetAllRecipes() ([]models.Recipe, error) {
	args := m.Called()
	return args.Get(0).([]models.Recipe), args.Error(1)
}

func (m *MockRecipeRepository) AddRecipe(recipe models.Recipe) error {
	args := m.Called(recipe)
	return args.Error(0)
}

func (m *MockRecipeRepository) SearchRecipesByCriteria(criteria map[string]string) ([]models.Recipe, error) {
	args := m.Called(criteria)
	return args.Get(0).([]models.Recipe), args.Error(1)
}
### ./internal/repository/mock_db.go ###
package repository

import (
	"database/sql"

	"github.com/stretchr/testify/mock"
)

type MockDB struct {
	mock.Mock
	*sql.DB
}

func (m *MockDB) Exec(query string, args ...interface{}) (sql.Result, error) {
	arguments := m.Called(append([]interface{}{query}, args...)...)
	return arguments.Get(0).(sql.Result), arguments.Error(1)
}

func (m *MockDB) QueryRow(query string, args ...interface{}) *sql.Row {
	arguments := m.Called(append([]interface{}{query}, args...)...)
	return arguments.Get(0).(*sql.Row)
}

func (m *MockDB) Query(query string, args ...interface{}) (*sql.Rows, error) {
	arguments := m.Called(append([]interface{}{query}, args...)...)
	return arguments.Get(0).(*sql.Rows), arguments.Error(1)
}
### ./internal/repository/user_repository_test.go ###
package repository_test

import (
	"fmt"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/josuejero/selestino/internal/models"
	"github.com/josuejero/selestino/internal/repository"
	"github.com/stretchr/testify/assert"
	"golang.org/x/crypto/bcrypt"
)

func TestCreateUser(t *testing.T) {
	fmt.Println("Starting TestCreateUser...")

	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := &repository.UserRepository{DB: db}
	fmt.Printf("UserRepository: %+v\n", repo)

	user := models.User{Username: "testuser", Password: "testpass", Role: "user"}
	fmt.Printf("User: %+v\n", user)

	mock.ExpectExec("INSERT INTO users").WithArgs(user.Username, sqlmock.AnyArg(), user.Role).
		WillReturnResult(sqlmock.NewResult(1, 1))

	err = repo.CreateUser(user)
	fmt.Printf("Error from CreateUser: %v\n", err)
	assert.NoError(t, err, "Error should be nil")
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}

func TestAuthenticateUser(t *testing.T) {
	fmt.Println("Starting TestAuthenticateUser...")

	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer db.Close()

	repo := &repository.UserRepository{DB: db}
	fmt.Printf("UserRepository: %+v\n", repo)

	user := models.User{Username: "testuser", Password: "testpass", Role: "user"}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		t.Fatalf("an error '%s' was not expected when hashing the password", err)
	}
	user.Password = string(hashedPassword)
	fmt.Printf("Hashed Password: %s\n", user.Password)

	rows := sqlmock.NewRows([]string{"username", "password", "role"}).
		AddRow(user.Username, user.Password, user.Role)
	mock.ExpectQuery("SELECT username, password, role FROM users WHERE username = \\$1").
		WithArgs("testuser").WillReturnRows(rows)

	returnedUser, authenticated, err := repo.AuthenticateUser("testuser", "testpass")
	fmt.Printf("Error from AuthenticateUser: %v\n", err)
	assert.NoError(t, err, "Error should be nil")

	fmt.Printf("Stored Password: %s\n", user.Password)
	fmt.Printf("Returned User: %+v\n", returnedUser)
	fmt.Printf("Authenticated: %v\n", authenticated)

	if !authenticated {
		t.Errorf("Expected authentication to be true, got false")
	}
	assert.True(t, authenticated, "User should be authenticated")
	assert.Equal(t, user.Username, returnedUser.Username, "Usernames should match")
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("there were unfulfilled expectations: %s", err)
	}
}
### ./internal/repository/user_repository.go ###
package repository

import (
	"database/sql"
	"log"

	"github.com/josuejero/selestino/internal/models"
	"golang.org/x/crypto/bcrypt"
)

type UserRepository struct {
	DB *sql.DB
}

func (r *UserRepository) CreateUser(user models.User) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error generating password hash: %v", err)
		return err
	}

	_, err = r.DB.Exec("INSERT INTO users (username, password, role) VALUES ($1, $2, $3)", user.Username, string(hashedPassword), user.Role)
	if err != nil {
		log.Printf("Error inserting user into database: %v", err)
	}
	return err
}

func (r *UserRepository) AuthenticateUser(username, password string) (models.User, bool, error) {
	var user models.User
	row := r.DB.QueryRow("SELECT username, password, role FROM users WHERE username = $1", username)
	err := row.Scan(&user.Username, &user.Password, &user.Role)
	if err != nil {
		log.Printf("Error fetching user from database: %v", err)
		return user, false, err
	}

	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		log.Printf("Error comparing password hash: %v", err)
		return user, false, nil
	}

	return user, true, nil
}
### ./internal/repository/recipe_repository_test.go ###
package repository_test

import (
	"database/sql"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/josuejero/selestino/internal/repository"
	"github.com/josuejero/selestino/pkg/config"
	"github.com/stretchr/testify/assert"
)

var repo *repository.RecipeRepository
var mock sqlmock.Sqlmock

func setupRecipeRepo(t *testing.T) func() {
	var db *sql.DB
	var err error

	db, mock, err = sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}

	config.InitRedis() // Initialize Redis client for the test

	repo = &repository.RecipeRepository{DB: db}

	return func() {
		db.Close()
	}
}

func TestGetAllRecipes(t *testing.T) {
	teardown := setupRecipeRepo(t)
	defer teardown()

	rows := sqlmock.NewRows([]string{"id", "name", "ingredients", "instructions"}).
		AddRow(1, "Ceviche", "Fish, Lemon, Salt", "Mix ingredients and serve")

	mock.ExpectQuery("SELECT id, name, ingredients, instructions FROM recipes").
		WillReturnRows(rows)

	recipes, err := repo.GetAllRecipes()
	assert.NoError(t, err)
	assert.Len(t, recipes, 1)
	assert.Equal(t, "Ceviche", recipes[0].Name)
}
### ./internal/models/user.go ###
package models

type User struct {
	ID       int    `json:"id"`
	Username string `json:"username"`
	Password string `json:"password"`
	Role     string `json:"role"`
}
### ./internal/models/recipe.go ###
package models

type Recipe struct {
	ID           int    `json:"id"`
	Name         string `json:"name"`
	Ingredients  string `json:"ingredients"`
	Instructions string `json:"instructions"`
}
### ./go.sum ###
github.com/DATA-DOG/go-sqlmock v1.5.0 h1:Shsta01QNfFxHCfpW6YH2STWB0MudeXXEWMr20OEh60=
github.com/DATA-DOG/go-sqlmock v1.5.0/go.mod h1:f/Ixk793poVmq4qj/V1dPUg2JEAKC73Q5eFN3EC/SaM=
github.com/DATA-DOG/go-sqlmock v1.5.2 h1:OcvFkGmslmlZibjAjaHm3L//6LiuBgolP7OputlJIzU=
github.com/DATA-DOG/go-sqlmock v1.5.2/go.mod h1:88MAG/4G7SMwSE3CeA0ZKzrT5CiOU3OJ+JlNzwDqpNU=
github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
github.com/go-redis/redis/v8 v8.11.5 h1:AcZZR7igkdvfVmQTPnu9WE37LRrO/YrBH5zWyjDC0oI=
github.com/go-redis/redis/v8 v8.11.5/go.mod h1:gREzHqY1hg6oD9ngVRbLStwAWKhA0FEgq8Jd4h5lpwo=
github.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=
github.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=
github.com/hashicorp/golang-lru v1.0.2 h1:dV3g9Z/unq5DpblPpw+Oqcv4dU/1omnb4Ok8iPY6p1c=
github.com/hashicorp/golang-lru v1.0.2/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=
github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=
github.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=
github.com/kisielk/sqlstruct v0.0.0-20201105191214-5f3e10d3ab46/go.mod h1:yyMNCyc/Ib3bDTKd379tNMpB/7/H5TjM2Y9QJ5THLbE=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=
github.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=
github.com/olivere/elastic/v7 v7.0.32 h1:R7CXvbu8Eq+WlsLgxmKVKPox0oOwAE/2T9Si5BnvK6E=
github.com/olivere/elastic/v7 v7.0.32/go.mod h1:c7PVmLe3Fxq77PIfY/bZmxY/TAamBhCzZ8xDOE09a9k=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
golang.org/x/crypto v0.24.0 h1:mnl8DM0o513X8fdIkmyFE/5hTYxbwYOjDS/+rK6qpRI=
golang.org/x/crypto v0.24.0/go.mod h1:Z1PMYSOR5nyMcyAVAIQSKCDwalqy85Aqn1x3Ws4L5DM=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=
golang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
### ./append_code.sh ###
#!/bin/bash

# Find and append relevant files to all_code.txt excluding .txt files and kubectl
find . -type f \( -name "*.go" -o -name "*.yaml" -o -name "*.yml" -o -name "*.md" -o -name "*.sh" -o -name "*.sql" -o -name "Jenkinsfile" -o -name "LICENSE" -o -name "dockerfile" -o -name "go.mod" -o -name "go.sum" -o -name "kubeconfig" -o -name "*.py" -o -name "*.log" \) \
    -not -name "*.txt" \
    -not -name "kubectl" \
    -exec sh -c 'echo "### {} ###" >> all_code.txt && cat "{}" >> all_code.txt' \;

echo "All code/text has been appended to all_code.txt."
### ./README.md ###
# Selestino

Selestino is a recipe website where users can input available ingredients and get relevant recipes for Peruvian dishes. This project leverages a variety of technologies including Golang, PostgreSQL, Docker, Kubernetes, and Jenkins for CI/CD.

## Table of Contents

- [Project Overview](#project-overview)
- [Features](#features)
- [Technologies Used](#technologies-used)
- [Setup and Installation](#setup-and-installation)
  - [Prerequisites](#prerequisites)
  - [Installation](#installation)
- [Usage](#usage)
  - [Running the Application](#running-the-application)
  - [API Endpoints](#api-endpoints)
- [Testing](#testing)
- [CI/CD Pipeline](#cicd-pipeline)
- [Contributing](#contributing)
- [License](#license)

## Project Overview

Selestino is designed to help users find Peruvian recipes based on the ingredients they have on hand. Users can register, log in, and search for recipes. The application supports JWT-based authentication and includes CI/CD pipelines for continuous integration and deployment.

## Features

- User registration and authentication
- Search recipes by ingredients and other criteria
- RESTful API for interacting with the application
- CI/CD pipeline with Jenkins
- Dockerized application for easy deployment
- Kubernetes for container orchestration

## Technologies Used

- Golang
- PostgreSQL
- Docker
- Kubernetes
- Jenkins
- JWT (JSON Web Tokens)
- Gorilla Mux
- Testify (testing framework)
- SQLMock (mocking SQL for tests)

## Setup and Installation

### Prerequisites

Ensure you have the following installed:

- Golang 1.20 or later
- Docker
- Docker Compose
- Kubernetes (Minikube or any other local Kubernetes setup)
- Jenkins (with necessary plugins)
- Git

### Installation

1. Clone the repository:

    ```bash
    git clone https://github.com/josuejero/selestino.git
    cd selestino
    ```

2. Set up the environment variables:

    Create a `.env` file in the root directory with the following content:

    ```env
    DB_HOST=postgres
    DB_PORT=5432
    DB_USER=selestino_user
    DB_PASSWORD=your_password
    DB_NAME=selestino
    JWT_SECRET_KEY=my_secret_key
    ```

3. Build and run the Docker containers:

    ```bash
    docker-compose up --build
    ```

4. Set up the Kubernetes environment:

    ```bash
    minikube start
    eval $(minikube -p minikube docker-env)
    docker build -t selestino:latest .
    kubectl apply -f k8s/postgres-deployment.yaml
    kubectl apply -f k8s/selestino-deployment.yaml
    ```

5. Access the application:

    ```bash
    minikube service selestino --url
    ```

## Usage

### Running the Application

After following the installation steps, you can access the application using the Minikube service URL. Use a tool like Postman or cURL to interact with the API endpoints.

### API Endpoints

- **Register User**
    ```http
    POST /register
    ```

    **Request Body:**
    ```json
    {
        "username": "exampleuser",
        "password": "password123"
    }
    ```

- **Login User**
    ```http
    POST /login
    ```

    **Request Body:**
    ```json
    {
        "username": "exampleuser",
        "password": "password123"
    }
    ```

- **Get All Recipes**
    ```http
    GET /recipes
    ```

- **Add Recipe**
    ```http
    POST /recipes
    ```

    **Request Body:**
    ```json
    {
        "name": "Lomo Saltado",
        "ingredients": "Beef, Onion, Tomato, Soy Sauce",
        "instructions": "Stir-fry ingredients and serve with rice"
    }
    ```

- **Search Recipes by Ingredients**
    ```http
    GET /recipes/search?ingredients=Beef,Tomato
    ```

## Testing

Run the tests to ensure all functionality is working correctly:

```bash
go test ./internal/repository
```

## CI/CD Pipeline

The CI/CD pipeline is set up using Jenkins. It automates the build, push, and deployment processes. The `Jenkinsfile` in the root directory defines the pipeline stages.

To configure the Jenkins pipeline:

1. Install Jenkins and necessary plugins.
2. Create credentials in Jenkins for Docker Hub and Kubernetes.
3. Create a new pipeline job and configure it to use the repository's `Jenkinsfile`.

## Contributing

Contributions are welcome! Please follow these steps:

1. Fork the repository.
2. Create a new branch (`git checkout -b feature-branch`).
3. Make your changes and commit them (`git commit -m 'Add new feature'`).
4. Push to the branch (`git push origin feature-branch`).
5. Create a pull request.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
### ./prometheus-operator-bundle.yaml ###
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: alertmanagers.monitoring.coreos.com
spec:
  group: monitoring.coreos.com
  names:
    kind: Alertmanager
    listKind: AlertmanagerList
    plural: alertmanagers
    singular: alertmanager
  scope: Namespaced
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              x-kubernetes-preserve-unknown-fields: true
### ./alertmanager-instance.yaml ###
apiVersion: monitoring.coreos.com/v1
kind: Alertmanager
metadata:
  name: alertmanager
  labels:
    app.kubernetes.io/name: alertmanager
spec:
  replicas: 1
  serviceAccountName: alertmanager
  resources:
    requests:
      memory: 200Mi
      cpu: 100m
    limits:
      memory: 500Mi
      cpu: 200m
---
apiVersion: v1
kind: Service
metadata:
  name: alertmanager
  labels:
    app.kubernetes.io/name: alertmanager
spec:
  type: NodePort
  ports:
  - name: web
    port: 9093
    targetPort: 9093
    nodePort: 30093
  selector:
    app.kubernetes.io/name: alertmanager
### ./kubeconfig ###
apiVersion: v1
clusters:
- cluster:
    certificate-authority: /var/jenkins_home/workspace/Selestino/ca.crt
    extensions:
    - extension:
        last-update: Sat, 08 Jun 2024 22:19:25 EDT
        provider: minikube.sigs.k8s.io
        version: v1.30.1
      name: cluster_info
    server: https://127.0.0.1:54190
  name: minikube
contexts:
- context:
    cluster: minikube
    extensions:
    - extension:
        last-update: Sat, 08 Jun 2024 22:19:25 EDT
        provider: minikube.sigs.k8s.io
        version: v1.30.1
      name: context_info
    namespace: default
    user: minikube
  name: minikube
current-context: minikube
kind: Config
preferences: {}
users:
- name: minikube
  user:
    client-certificate: /var/jenkins_home/workspace/Selestino/client.crt
    client-key: /var/jenkins_home/workspace/Selestino/client.key

### ./problem.py ###
import os
import subprocess

# Path to the file
file_path = "all_code.txt"

# Delete the content of the file
with open(file_path, "w") as file:
    pass

# Function to get multi-line input with a special end keyword
def get_multiline_input(prompt):
    print(prompt)
    print("Type 'END' on a new line to finish.")
    lines = []
    while True:
        line = input()
        if line.strip().upper() == 'END':
            break
        lines.append(line)
    return "\n".join(lines)

# Get user input for the problem with the code
problem_message = get_multiline_input("Enter the problem with the code:")

# Write the problem message and introductory text to the top of the file
with open(file_path, "a") as file:
    file.write(f"{problem_message}\n\n")
    file.write("Please analyze this project structure, description, and errors carefully in order to help me with the issue.\n\n")

# Append the content of README.md to the file
with open("README.md", "r") as readme_file:
    readme_content = readme_file.read()

with open(file_path, "a") as file:
    file.write("### README.md ###\n")
    file.write(readme_content)
    file.write("\n\n")

# Append the output of the tree command to the file
tree_output = subprocess.run(["tree"], capture_output=True, text=True)
with open(file_path, "a") as file:
    file.write(tree_output.stdout)
    file.write("\n")

# Define the Bash script content
bash_script_content = """#!/bin/bash

# Find and append relevant files to all_code.txt excluding .txt files and kubectl
find . -type f \\( -name "*.go" -o -name "*.yaml" -o -name "*.yml" -o -name "*.md" -o -name "*.sh" -o -name "*.sql" -o -name "Jenkinsfile" -o -name "LICENSE" -o -name "dockerfile" -o -name "go.mod" -o -name "go.sum" -o -name "kubeconfig" -o -name "*.py" -o -name "*.log" \\) \\
    -not -name "*.txt" \\
    -not -name "kubectl" \\
    -exec sh -c 'echo "### {} ###" >> all_code.txt && cat "{}" >> all_code.txt' \\;

echo "All code/text has been appended to all_code.txt."
"""

# Write the Bash script content to a temporary file
with open("append_code.sh", "w") as bash_script:
    bash_script.write(bash_script_content)

# Run the Bash script
subprocess.run(["bash", "append_code.sh"])

# Clean up the temporary Bash script
os.remove("append_code.sh")

# Copy the content of all_code.txt to the clipboard using pbcopy
with open(file_path, "r") as file:
    all_code_content = file.read()

subprocess.run("pbcopy", text=True, input=all_code_content)

print("All steps completed and all_code.txt has been updated and copied to clipboard.")
### ./prometheus_setup_output.log ###
customresourcedefinition.apiextensions.k8s.io/alertmanagerconfigs.monitoring.coreos.com unchanged
customresourcedefinition.apiextensions.k8s.io/podmonitors.monitoring.coreos.com unchanged
customresourcedefinition.apiextensions.k8s.io/probes.monitoring.coreos.com unchanged
customresourcedefinition.apiextensions.k8s.io/prometheusrules.monitoring.coreos.com unchanged
customresourcedefinition.apiextensions.k8s.io/scrapeconfigs.monitoring.coreos.com unchanged
customresourcedefinition.apiextensions.k8s.io/servicemonitors.monitoring.coreos.com unchanged
clusterrolebinding.rbac.authorization.k8s.io/prometheus-operator unchanged
clusterrole.rbac.authorization.k8s.io/prometheus-operator unchanged
deployment.apps/prometheus-operator unchanged
serviceaccount/prometheus-operator unchanged
service/prometheus-operator unchanged
### ./Jenkinsfile ###
pipeline {
    agent any

    environment {
        DOCKER_CREDENTIALS_ID = 'dockerhub-credentials'
        KUBECONFIG_CREDENTIALS_ID = 'kubeconfig-credentials'
        DOCKER_REPO = 'josuejero/selestino'
        KUBECONFIG = "/root/.kube/config"
    }

    stages {
        stage('Checkout') {
            steps {
                echo "Checking out SCM..."
                checkout scm
                echo "SCM checkout completed."
            }
        }

        stage('Prepare Environment') {
            steps {
                script {
                    echo "Preparing environment..."
                    // Copy cert files to the workspace
                    sh 'cp /ca.crt $WORKSPACE/ca.crt'
                    sh 'cp /client.crt $WORKSPACE/client.crt'
                    sh 'cp /client.key $WORKSPACE/client.key'
                    echo "Cert files copied to workspace:"
                    sh 'ls -l $WORKSPACE'
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo "Setting Docker context to default..."
                    sh 'docker context use default'
                    sh 'docker --version'
                    echo "Building Docker image..."
                    docker.build("${DOCKER_REPO}:latest")
                    echo "Docker image built successfully"
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    echo "Listing Docker contexts..."
                    sh 'docker context ls'
                    sh 'docker context use default'
                    echo "Pushing Docker image to repository..."
                    withDockerRegistry([url: 'https://index.docker.io/v1/', credentialsId: DOCKER_CREDENTIALS_ID]) {
                        docker.image("${DOCKER_REPO}:latest").push()
                    }
                    echo "Docker image pushed successfully"
                }
            }
        }

        stage('Run Tests') {
            steps {
                script {
                    echo "Running tests in Docker container..."
                    docker.image('golang:1.20-alpine').inside('-u root:root') {
                        sh 'apk --no-cache add git'
                        echo "Running tests..."
                        sh 'go test -v ./... -coverprofile=coverage.out'
                        sh 'go tool cover -html=coverage.out -o coverage.html'
                        echo "Tests completed"
                        echo "Test output:"
                        sh 'cat coverage.out'
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    withKubeConfig([credentialsId: KUBECONFIG_CREDENTIALS_ID]) {
                        docker.image('alpine:latest').inside('-u root') {
                            echo "Installing Docker and kubectl..."
                            sh '''
                            apk --no-cache add curl docker openrc
                            if ! (service docker status | grep -q 'is running'); then
                                if ! (service docker status | grep -q 'is starting'); then
                                    service docker start
                                    echo "Checking Docker status..."
                                    while ! docker info > /dev/null 2>&1; do
                                        echo "Waiting for Docker to start..."
                                        sleep 1
                                    done
                                else
                                    echo "Docker is already starting"
                                fi
                            else
                                echo "Docker is already running"
                            fi
                            docker --version
                            curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
                            chmod +x ./kubectl
                            mv ./kubectl /usr/local/bin/kubectl
                            kubectl version --client
                            '''
                            echo "Docker and kubectl installed successfully"

                            echo "Creating .kube directory and copying kubeconfig"
                            sh 'mkdir -p /root/.kube'
                            sh 'cp $WORKSPACE/ca.crt /root/.kube/ca.crt'
                            sh 'cp $WORKSPACE/client.crt /root/.kube/client.crt'
                            sh 'cp $WORKSPACE/client.key /root/.kube/client.key'
                            sh 'cp $WORKSPACE/kubeconfig /root/.kube/config'

                            echo "Validating kubeconfig path and contents..."
                            sh 'ls -l /root/.kube/config'
                            sh 'cat /root/.kube/config'

                            echo "Checking for certificate files..."
                            sh 'ls -l /root/.kube/'
                            sh 'cat /root/.kube/client.crt'
                            sh 'cat /root/.kube/client.key'
                            sh 'cat /root/.kube/ca.crt'

                            echo "Validating Minikube status..."
                            sh '''
                            curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64
                            chmod +x minikube
                            mv minikube /usr/local/bin/
                            minikube status || minikube start --driver=docker
                            '''

                            echo "Applying Kubernetes configurations..."
                            sh '''
                            kubectl config set-cluster minikube --certificate-authority=/root/.kube/ca.crt --embed-certs=true
                            kubectl config set-credentials minikube --client-certificate=/root/.kube/client.crt --client-key=/root/.kube/client.key --embed-certs=true
                            kubectl config set-context minikube --cluster=minikube --user=minikube
                            kubectl config use-context minikube
                            kubectl apply -f k8s/elasticsearch-deployment.yaml --validate=false
                            kubectl apply -f k8s/postgres-deployment.yaml --validate=false
                            kubectl apply -f k8s/selestino-deployment.yaml --validate=false
                            kubectl apply -f k8s/redis-deployment.yaml --validate=false
                            '''
                            echo "Kubernetes configurations applied"

                            echo "Listing Kubernetes pods..."
                            sh 'kubectl get pods -o wide'
                        }
                    }
                }
            }
        }

        stage('Publish Coverage Report') {
            steps {
                echo "Publishing coverage report..."
                publishHTML(target: [
                    reportDir: '.',
                    reportFiles: 'coverage.html',
                    reportName: 'Coverage Report'
                ])
            }
        }
    }

    post {
        success {
            echo 'Pipeline completed successfully'
        }
        failure {
            echo 'Pipeline failed'
        }
        always {
            echo "Cleaning up workspace..."
            cleanWs()
        }
    }
}
### ./prometheus-operator-components.yaml ###
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus-operator
rules:
  - apiGroups:
      - ""
    resources:
      - pods
      - nodes
      - services
      - endpoints
      - nodes/proxy
      - nodes/metrics
    verbs:
      - get
      - list
      - watch
  # Add other necessary rules here

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus-operator
  namespace: default

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus-operator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus-operator
subjects:
  - kind: ServiceAccount
    name: prometheus-operator
    namespace: default

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus-operator
  namespace: default
spec:
  replicas: 1
  selector:
    matchLabels:
      name: prometheus-operator
  template:
    metadata:
      labels:
        name: prometheus-operator
    spec:
      serviceAccountName: prometheus-operator
      containers:
        - name: prometheus-operator
          image: quay.io/prometheus-operator/prometheus-operator:v0.50.0
          args:
            - --kubelet-service=kube-system/kubelet
            - --config-reloader-image=quay.io/prometheus-operator/prometheus-config-reloader:v0.50.0
            - --prometheus-config-reloader=quay.io/prometheus-operator/prometheus-config-reloader:v0.50.0
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
  # Add other necessary configurations here

---
apiVersion: v1
kind: Service
metadata:
  name: prometheus-operator
  namespace: default
spec:
  ports:
    - port: 8080
      targetPort: 8080
  selector:
    name: prometheus-operator
### ./api/handlers_test.go ###
package api_test

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/josuejero/selestino/api"
	"github.com/josuejero/selestino/internal/models"
	"github.com/josuejero/selestino/internal/repository"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

var mockRecipeRepo *repository.MockRecipeRepository

func setup() {
	mockRecipeRepo = &repository.MockRecipeRepository{}
	api.SetRecipeRepo(mockRecipeRepo)
}

func TestGetRecipes(t *testing.T) {
	setup()

	mockRecipeRepo.On("GetAllRecipes").Return([]models.Recipe{
		{Name: "Ceviche", Ingredients: "Fish, Lemon, Salt", Instructions: "Mix ingredients and serve"},
	}, nil)

	req, _ := http.NewRequest("GET", "/recipes", nil)
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(api.GetRecipes)
	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var recipes []models.Recipe
	err := json.NewDecoder(rr.Body).Decode(&recipes)
	assert.NoError(t, err)
	assert.NotEmpty(t, recipes)
}

func TestAddRecipe(t *testing.T) {
	setup()

	mockRecipeRepo.On("AddRecipe", mock.AnythingOfType("models.Recipe")).Return(nil)

	recipe := models.Recipe{Name: "Test Recipe", Ingredients: "Test Ingredients", Instructions: "Test Instructions"}
	payload, _ := json.Marshal(recipe)
	req, _ := http.NewRequest("POST", "/recipes", bytes.NewBuffer(payload))
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(api.AddRecipe)
	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusCreated, rr.Code)
}

func TestSearchRecipesByCriteria(t *testing.T) {
	setup()

	mockRecipeRepo.On("SearchRecipesByCriteria", mock.AnythingOfType("map[string]string")).Return([]models.Recipe{
		{Name: "Test Recipe", Ingredients: "Test Ingredients", Instructions: "Test Instructions"},
	}, nil)

	req, _ := http.NewRequest("GET", "/recipes/search?ingredients=Test+Ingredients", nil)
	rr := httptest.NewRecorder()
	handler := http.HandlerFunc(api.SearchRecipesByCriteria)
	handler.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)
	var recipes []models.Recipe
	err := json.NewDecoder(rr.Body).Decode(&recipes)
	assert.NoError(t, err)
	assert.NotEmpty(t, recipes)
}
### ./api/middleware_test.go ###
package api_test

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gorilla/mux"
	"github.com/josuejero/selestino/api"
	"github.com/stretchr/testify/assert"
)

func TestRoleBasedAuthorization(t *testing.T) {
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	adminToken, _ := api.GenerateToken("admin_user", "admin")
	req, _ := http.NewRequest("GET", "/", nil)
	req.AddCookie(&http.Cookie{Name: "token", Value: adminToken})

	rr := httptest.NewRecorder()
	router := mux.NewRouter()
	router.Handle("/", api.RoleBasedAuthorization("admin")(handler))
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusOK, rr.Code)

	userToken, _ := api.GenerateToken("regular_user", "user")
	req, _ = http.NewRequest("GET", "/", nil)
	req.AddCookie(&http.Cookie{Name: "token", Value: userToken})

	rr = httptest.NewRecorder()
	router.ServeHTTP(rr, req)

	assert.Equal(t, http.StatusForbidden, rr.Code)
}
### ./api/rate_limiter.go ###
package api

import (
	"net/http"
	"sync"
	"time"

	lru "github.com/hashicorp/golang-lru"
)

type RateLimiter struct {
	requests     *lru.Cache
	mutex        sync.Mutex
	rateLimit    int
	rateLimitDur time.Duration
}

func NewRateLimiter(size int, rateLimit int, rateLimitDur time.Duration) *RateLimiter {
	cache, _ := lru.New(size)
	return &RateLimiter{
		requests:     cache,
		rateLimit:    rateLimit,
		rateLimitDur: rateLimitDur,
	}
}

func (rl *RateLimiter) Limit(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		rl.mutex.Lock()
		defer rl.mutex.Unlock()

		ip := r.RemoteAddr
		if val, ok := rl.requests.Get(ip); ok {
			reqInfo := val.(*requestInfo)
			if time.Since(reqInfo.timestamp) < rl.rateLimitDur {
				if reqInfo.count >= rl.rateLimit {
					http.Error(w, "Too many requests", http.StatusTooManyRequests)
					return
				}
				reqInfo.count++
			} else {
				reqInfo.count = 1
				reqInfo.timestamp = time.Now()
			}
		} else {
			rl.requests.Add(ip, &requestInfo{count: 1, timestamp: time.Now()})
		}

		next.ServeHTTP(w, r)
	})
}

type requestInfo struct {
	count     int
	timestamp time.Time
}
### ./api/handlers.go ###
package api

import (
	"encoding/json"
	"net/http"

	"github.com/josuejero/selestino/internal/models"
	"github.com/josuejero/selestino/internal/repository"
)

var recipeRepo repository.RecipeRepositoryInterface

func SetRecipeRepo(r repository.RecipeRepositoryInterface) {
	recipeRepo = r
}

func GetRecipes(w http.ResponseWriter, r *http.Request) {
	recipes, err := recipeRepo.GetAllRecipes()
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(recipes)
}

func AddRecipe(w http.ResponseWriter, r *http.Request) {
	var recipe models.Recipe
	if err := json.NewDecoder(r.Body).Decode(&recipe); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	if err := recipeRepo.AddRecipe(recipe); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
}

func SearchRecipesByCriteria(w http.ResponseWriter, r *http.Request) {
	criteria := make(map[string]string)
	for key, values := range r.URL.Query() {
		criteria[key] = values[0]
	}

	recipes, err := recipeRepo.SearchRecipesByCriteria(criteria)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(recipes)
}
### ./api/middleware.go ###
// api/middleware.go

package api

import (
	"net/http"
	"strings"

	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
)

func RoleBasedAuthorization(roles ...string) mux.MiddlewareFunc {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			cookie, err := r.Cookie("token")
			if err != nil {
				if err == http.ErrNoCookie {
					http.Error(w, "Unauthorized", http.StatusUnauthorized)
					return
				}
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}

			tokenStr := cookie.Value
			claims := &Claims{}
			token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
				return jwtKey, nil
			})

			if err != nil {
				if err == jwt.ErrSignatureInvalid {
					http.Error(w, "Unauthorized", http.StatusUnauthorized)
					return
				}
				http.Error(w, err.Error(), http.StatusBadRequest)
				return
			}

			if !token.Valid {
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}

			authorized := false
			for _, role := range roles {
				if strings.EqualFold(claims.Role, role) {
					authorized = true
					break
				}
			}

			if !authorized {
				http.Error(w, "Forbidden", http.StatusForbidden)
				return
			}

			next.ServeHTTP(w, r)
		})
	}
}
### ./api/rate_limiter_test.go ###
package api_test

import (
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/josuejero/selestino/api"
	"github.com/stretchr/testify/assert"
)

func TestRateLimiter(t *testing.T) {
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	})

	rateLimiter := api.NewRateLimiter(100, 2, time.Second)
	limitedHandler := rateLimiter.Limit(handler)

	req, _ := http.NewRequest("GET", "/", nil)
	rr := httptest.NewRecorder()

	// First request should pass
	limitedHandler.ServeHTTP(rr, req)
	assert.Equal(t, http.StatusOK, rr.Code)

	// Second request should pass
	rr = httptest.NewRecorder()
	limitedHandler.ServeHTTP(rr, req)
	assert.Equal(t, http.StatusOK, rr.Code)

	// Third request should be rate limited
	rr = httptest.NewRecorder()
	limitedHandler.ServeHTTP(rr, req)
	assert.Equal(t, http.StatusTooManyRequests, rr.Code)
}
### ./api/token_helper.go ###
package api

import (
	"time"

	"github.com/dgrijalva/jwt-go"
)

func GenerateToken(username, role string) (string, error) {
	expirationTime := time.Now().Add(24 * time.Hour)
	claims := &Claims{
		Username: username,
		Role:     role,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		return "", err
	}

	return tokenString, nil
}
### ./api/router.go ###
package api

import (
	"database/sql"
	"encoding/json"
	"net/http"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gorilla/mux"
	"github.com/josuejero/selestino/internal/models"
	"github.com/josuejero/selestino/internal/repository"
)

var userRepo *repository.UserRepository

func InitializeRouter(db *sql.DB) *mux.Router {
	userRepo = &repository.UserRepository{DB: db}
	SetRecipeRepo(&repository.RecipeRepository{DB: db})

	router := mux.NewRouter()

	// Define rate limiter
	rateLimiter := NewRateLimiter(1000, 10, time.Minute)

	// Define your API routes here
	router.HandleFunc("/recipes", GetRecipes).Methods("GET")
	router.HandleFunc("/recipes", AddRecipe).Methods("POST")
	router.HandleFunc("/recipes/search", SearchRecipesByCriteria).Methods("GET")

	router.HandleFunc("/register", RegisterUser).Methods("POST")
	router.HandleFunc("/login", LoginUser).Methods("POST")

	// Apply rate limiter middleware to all routes
	router.Use(rateLimiter.Limit)

	// Apply role-based middleware to protected routes
	adminRoutes := router.PathPrefix("/admin").Subrouter()
	adminRoutes.Use(RoleBasedAuthorization("admin"))
	adminRoutes.HandleFunc("/recipes", AddRecipe).Methods("POST")

	return router
}

var jwtKey = []byte("my_secret_key")

type Claims struct {
	Username string `json:"username"`
	Role     string `json:"role"`
	jwt.StandardClaims
}

func RegisterUser(w http.ResponseWriter, r *http.Request) {
	var user models.User
	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	if err := userRepo.CreateUser(user); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusCreated)
}

func LoginUser(w http.ResponseWriter, r *http.Request) {
	var user models.User
	if err := json.NewDecoder(r.Body).Decode(&user); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	authenticatedUser, authenticated, err := userRepo.AuthenticateUser(user.Username, user.Password)
	if err != nil || !authenticated {
		http.Error(w, "Invalid username or password", http.StatusUnauthorized)
		return
	}

	expirationTime := time.Now().Add(24 * time.Hour)
	claims := &Claims{
		Username: authenticatedUser.Username,
		Role:     authenticatedUser.Role,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &http.Cookie{
		Name:    "token",
		Value:   tokenString,
		Expires: expirationTime,
	})
}
### ./docker-compose.yml ###
version: '3.8'

services:
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: selestino
      POSTGRES_USER: selestino_user
      POSTGRES_PASSWORD: your_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d selestino -U selestino_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:latest
    ports:
      - "6379:6379"

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.1
    environment:
      discovery.type: single-node
    ports:
      - "9200:9200"

  app:
    build: .
    ports:
      - "8081:8080"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_started
      elasticsearch:
        condition: service_started
    environment:
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: selestino_user
      DB_PASSWORD: your_password
      DB_NAME: selestino
      JWT_SECRET_KEY: my_secret_key
      REDIS_ADDR: redis:6379
      ELASTICSEARCH_URL: http://elasticsearch:9200

  jenkins:
    image: jenkins/jenkins:lts
    ports:
      - "8080:8080"
      - "50000:50000"
    volumes:
      - jenkins_data:/var/jenkins_home

volumes:
  postgres_data:
  jenkins_data:
### ./jenkins-deployment.yaml ###
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jenkins
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jenkins
  template:
    metadata:
      labels:
        app: jenkins
    spec:
      containers:
      - name: jenkins
        image: jenkins/jenkins:lts
        ports:
        - containerPort: 8080
        - containerPort: 50000
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        volumeMounts:
        - name: jenkins-home
          mountPath: /var/jenkins_home
      volumes:
      - name: jenkins-home
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: jenkins
spec:
  type: NodePort
  ports:
  - name: http
    port: 8080
    targetPort: 8080
    nodePort: 30001  # Specify the NodePort here
  - name: agent
    port: 50000
    targetPort: 50000
  selector:
    app: jenkins
### ./prometheus-instance.yaml ###
apiVersion: monitoring.coreos.com/v1
kind: Prometheus
metadata:
  name: prometheus
  labels:
    app.kubernetes.io/name: prometheus
spec:
  replicas: 1
  serviceAccountName: prometheus-operator
  serviceMonitorSelector:
    matchLabels:
      team: frontend
  resources:
    requests:
      memory: 2Gi
      cpu: 1
    limits:
      memory: 4Gi
      cpu: 2
  alerting:
    alertmanagers:
      - namespace: default
        name: alertmanager
        port: web
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus
  labels:
    app.kubernetes.io/name: prometheus
spec:
  type: NodePort
  ports:
  - name: web
    port: 9090
    targetPort: 9090
    nodePort: 30090
  selector:
    app.kubernetes.io/name: prometheus
### ./values.yaml ###
prometheus:
  prometheusSpec:
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1Gi"

alertmanager:
  alertmanagerSpec:
    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
      limits:
        memory: "2Gi"
        cpu: "1Gi"
### ./prometheus-crds.yaml ###
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: alertmanagers.monitoring.coreos.com
spec:
  group: monitoring.coreos.com
  names:
    kind: Alertmanager
    listKind: AlertmanagerList
    plural: alertmanagers
    singular: alertmanager
  scope: Namespaced
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              x-kubernetes-preserve-unknown-fields: true

---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: prometheuses.monitoring.coreos.com
spec:
  group: monitoring.coreos.com
  names:
    kind: Prometheus
    listKind: PrometheusList
    plural: prometheuses
    singular: prometheus
  scope: Namespaced
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              x-kubernetes-preserve-unknown-fields: true

---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: servicemonitors.monitoring.coreos.com
spec:
  group: monitoring.coreos.com
  names:
    kind: ServiceMonitor
    listKind: ServiceMonitorList
    plural: servicemonitors
    singular: servicemonitor
  scope: Namespaced
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              x-kubernetes-preserve-unknown-fields: true

# Add other necessary CRDs similarly
### ./pkg/config/config.go ###
package config

import (
    "database/sql"
    "fmt"
    _ "github.com/lib/pq"
    "log"
    "os"
)

func Connect() *sql.DB {
    host := os.Getenv("DB_HOST")
    port := os.Getenv("DB_PORT")
    user := os.Getenv("DB_USER")
    password := os.Getenv("DB_PASSWORD")
    dbname := os.Getenv("DB_NAME")

    psqlInfo := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
        host, port, user, password, dbname)

    db, err := sql.Open("postgres", psqlInfo)
    if err != nil {
        log.Fatalf("Error opening database: %v", err)
    }

    if err := db.Ping(); err != nil {
        log.Fatalf("Error connecting to the database: %v", err)
    }

    fmt.Println("Successfully connected to the database!")
    return db
}
### ./pkg/config/cache.go ###
// pkg/config/cache.go

package config

import (
	"context"
	"os"

	"github.com/go-redis/redis/v8"
)

var RedisClient *redis.Client

func InitRedis() {
	RedisClient = redis.NewClient(&redis.Options{
		Addr:     os.Getenv("REDIS_ADDR"),
		Password: "", // no password set
		DB:       0,  // use default DB
	})
}

func GetRedisClient() *redis.Client {
	return RedisClient
}

func SetRedis(ctx context.Context, key string, value interface{}) error {
	return RedisClient.Set(ctx, key, value, 0).Err()
}

func GetRedis(ctx context.Context, key string) (string, error) {
	return RedisClient.Get(ctx, key).Result()
}

func DelRedis(ctx context.Context, key string) error {
	return RedisClient.Del(ctx, key).Err()
}
### ./pkg/config/search.go ###
// pkg/config/search.go

package config

import (
	"context"
	"log"
	"os"

	"github.com/olivere/elastic/v7"
)

var ESClient *elastic.Client

func InitElasticsearch() {
	var err error
	ESClient, err = elastic.NewClient(
		elastic.SetURL(os.Getenv("ELASTICSEARCH_URL")),
		elastic.SetSniff(false),
	)
	if err != nil {
		log.Fatalf("Error initializing Elasticsearch client: %v", err)
	}
}

func CreateIndex(index string, mapping string) error {
	ctx := context.Background()
	exists, err := ESClient.IndexExists(index).Do(ctx)
	if err != nil {
		return err
	}

	if !exists {
		_, err = ESClient.CreateIndex(index).BodyString(mapping).Do(ctx)
		if err != nil {
			return err
		}
	}

	return nil
}

func IndexDocument(index string, id string, doc interface{}) error {
	ctx := context.Background()
	_, err := ESClient.Index().
		Index(index).
		Id(id).
		BodyJson(doc).
		Do(ctx)
	return err
}
